# 11.8 第二個例子：讀和寫

讀和寫是軟體中很普遍的行為，提起它們會立即想到讀寫文件、快取（比如位元組或字串切片）、標準輸入輸出、標準錯誤以及網路連接、管道等等，或者讀寫我們的自訂類型。為了讓代碼儘可能通用，Go 採取了一致的方式來讀寫數據。

`io` 包提供了用於讀和寫的介面 `io.Reader` 和 `io.Writer`：

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
```

只要類型實現了讀寫介面，提供 `Read()` 和 `Write` 方法，就可以從它讀取數據，或向它寫入數據。一個對象要是可讀的，它必須實現 `io.Reader` 介面，這個介面只有一個簽名是 `Read(p []byte) (n int, err error)` 的方法，它從調用它的對象上讀取數據，並把讀到的數據放入參數中的位元組切片中，然後返回讀取的位元組數和一個 `error` 對象，如果沒有錯誤發生返回 `nil`，如果已經到達輸入的尾端，會返回 `io.EOF("EOF")`，如果讀取的過程中發生了錯誤，就會返回具體的錯誤訊息。類似地，一個對象要是可寫的，它必須實現 `io.Writer` 介面，這個介面也只有一個簽名是 `Write(p []byte) (n int, err error)` 的方法，它將指定位元組切片中的數據寫入調用它的對象裡，然後返回實際寫入的位元組數和一個 `error` 對象（如果沒有錯誤發生就是 `nil`）。

`io` 包裡的 `Readers` 和 `Writers` 都是不帶緩衝的，`bufio` 包裡提供了對應的帶緩衝的操作，在讀寫 `UTF-8` 編碼的文本文件時它們尤其有用。在 第12章 我們會看到很多在實戰中使用它們的例子。

在實際編程中儘可能的使用這些介面，會使程序變得更通用，可以在任何實現了這些介面的類型上使用讀寫方法。

例如一個 `JPEG` 圖形解碼器，通過一個 `Reader` 參數，它可以解碼來自磁碟、網路連接或以 `gzip` 壓縮的 `HTTP` 流中的 `JPEG` 圖形數據，或者其他任何實現了 `Reader` 介面的對象。 

## 連結

- [目錄](directory.md)
- 上一節：[第一個例子：使用Sorter介面排序](11.7.md)
- 下一節：[空介面](11.9.md)
